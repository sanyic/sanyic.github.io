<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DataLab</title>
    <url>/2021/12/15/CSAPP-Lab/DataLab/</url>
    <content><![CDATA[<h1 id="Data-Lab"><a href="#Data-Lab" class="headerlink" title="Data Lab"></a>Data Lab</h1><p>用!  ̃ &amp; ˆ | + &lt;&lt; &gt;&gt;实现下列函数</p>
<p><img src="/2021/12/15/CSAPP-Lab/DataLab/image-20211220133136361.png" alt="image-20211220133136361"></p>
<p>中文的题干</p>
<p><img src="/2021/12/15/CSAPP-Lab/DataLab/image-20211220163157477.png" alt="image-20211220163157477"></p>
<h2 id="bitXor-x-y"><a href="#bitXor-x-y" class="headerlink" title="bitXor(x,y)"></a>bitXor(x,y)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitxor</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ~(m &amp; n)&amp;~(~m &amp; ~n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本来没想明白，后来想从集合的角度看一下，发现^在集合表示中叫离散差。表示如下：</p>
<p><img src="/2021/12/15/CSAPP-Lab/DataLab/DataLab%5Cimage-20211220170658367.png" alt="image-20211220170658367"></p>
<h2 id="tmin"><a href="#tmin" class="headerlink" title="tmin()"></a>tmin()</h2><p>返回int的最小值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0x1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于补码的首位有很高的负权，其他都是正权，int是32位</p>
<p>构造出0x10000000000000000000000000000000。</p>
<h2 id="isTmax（x）"><a href="#isTmax（x）" class="headerlink" title="isTmax（x）"></a>isTmax（x）</h2><p>判断参数是否是补码的最大值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !(~(<span class="number">0x1</span> &lt;&lt; <span class="number">31</span>) ^ x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用到了上一个题目的知识，~取得最大值，用^判断是否相等。</p>
<p>网上找到了另一个版本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = x + <span class="number">1</span>;<span class="comment">//Tmin,1000...</span></span><br><span class="line">	x = x + i;<span class="comment">//-1,1111...</span></span><br><span class="line">	x = ~x;<span class="comment">//0,0000...</span></span><br><span class="line">	i = !i;<span class="comment">//exclude x=0xffff...</span></span><br><span class="line">	x = x + i;<span class="comment">//exclude x=0xffff...</span></span><br><span class="line">	<span class="keyword">return</span> !x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="allOddBits-x"><a href="#allOddBits-x" class="headerlink" title="allOddBits(x)"></a>allOddBits(x)</h2><p>判断所有奇数位是否都为1，这里的奇数指的是位的阶级是2的几次幂.。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !(<span class="number">0xAAAA</span> ^ x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑掩码用0xAAAA可以得到各个奇数位上为1的掩码用&amp;，^等运算都能表示出来。</p>
<h2 id="negate-x"><a href="#negate-x" class="headerlink" title="negate(x)"></a>negate(x)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补码等于取反+1</p>
<h2 id="isAsciiDigit-x"><a href="#isAsciiDigit-x" class="headerlink" title="isAsciiDigit(x)"></a>isAsciiDigit(x)</h2><p>计算输入值是否是数字 0-9 的 ASCII值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sign,upperBound,lowerBound;</span><br><span class="line">	sign = <span class="number">0x1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">	upperBound = ~(sign | <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="string">&#x27;9&#x27;</span>));<span class="comment">//构造一个差0x39溢出的数字</span></span><br><span class="line">	lowerBound = ~<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="string">&#x27;0&#x27;</span>) + <span class="number">1</span>;<span class="comment">//构造一个差0x30溢出的数字</span></span><br><span class="line">	upperBound = sign &amp; (upperBound + x) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">	lowerBound = sign &amp; (lowerBound + x) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">	<span class="keyword">return</span>  !(upperBound | lowerBound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考的思路是找到两个特殊的边界数值再<strong>利用sign的符号位</strong>来进行判断。</p>
<h2 id="conditional-x-y-z"><a href="#conditional-x-y-z" class="headerlink" title="conditional(x, y, z)"></a>conditional(x, y, z)</h2><p>位运算模拟三目运算<code>x?y:z</code> </p>
<p>用条件分支来说类似于下面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x)</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> z;</span><br></pre></td></tr></table></figure>

<p>但这里我们不能用条件分支，需要在一个表达式结合两个结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span> <span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    x = !!x;</span><br><span class="line">    x = ~x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x&amp;y)|((~(!x)+<span class="number">1</span>)&amp;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isLessOrEqual-x-y"><a href="#isLessOrEqual-x-y" class="headerlink" title="isLessOrEqual(x,y)"></a>isLessOrEqual(x,y)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = x + (~y + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> !!((!result) | (result &amp; (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = x + (~y + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> !!((!result) | (result &gt;&gt;<span class="number">31</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="logicalNeg-x"><a href="#logicalNeg-x" class="headerlink" title="logicalNeg(x)"></a>logicalNeg(x)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (((<span class="keyword">unsigned</span> <span class="keyword">int</span>)x &gt;&gt;<span class="number">31</span>)^ <span class="number">1</span>)&amp;((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(~x+<span class="number">1</span>)&gt;&gt;<span class="number">31</span> ^<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="howManyBits-x"><a href="#howManyBits-x" class="headerlink" title="howManyBits(x)"></a>howManyBits(x)</h2><h2 id="floatFloatScale2-uf"><a href="#floatFloatScale2-uf" class="headerlink" title="floatFloatScale2(uf)"></a>floatFloatScale2(uf)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">floatFloatScale2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> uf)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sign = uf &gt;&gt; <span class="number">31</span>&amp; <span class="number">0x1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">exp</span> = (uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> frac = uf &amp; <span class="number">0x7ffff</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">255</span>)</span><br><span class="line">		<span class="keyword">return</span> uf;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>)</span><br><span class="line">		frac &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">exp</span> += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> frac | (sign &lt;&lt; <span class="number">31</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="floatFloat2Int-uf"><a href="#floatFloat2Int-uf" class="headerlink" title="floatFloat2Int(uf)"></a>floatFloat2Int(uf)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">exp</span> = (uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">	<span class="keyword">int</span> sign = (uf &gt;&gt; <span class="number">31</span>);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> frac = (uf &amp; <span class="number">0x7ffff</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">exp</span> &lt; <span class="number">127</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> &gt; <span class="number">158</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		frac = frac | <span class="number">1</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">exp</span> &lt; <span class="number">150</span>)</span><br><span class="line">			frac &gt;&gt;= (<span class="number">150</span> - <span class="built_in">exp</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			frac &lt;&lt;= (<span class="built_in">exp</span> - <span class="number">150</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> frac | (sign &lt;&lt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2()"></a>floatPower2()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatpower2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e = x +<span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span>(e &gt;= <span class="number">0xFF</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> e &lt;&lt;<span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSAPP Lab</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>PE格式</title>
    <url>/2021/12/14/Windows/PE/</url>
    <content><![CDATA[<h1 id="PE基本介绍"><a href="#PE基本介绍" class="headerlink" title="PE基本介绍"></a>PE基本介绍</h1><p>PE（Portable Executable）可移植可执行文件，在COFF格式的基础上制作来。提高程序在不同平台的可移植性。</p>
<p>PE一般指PE32,64位的可执行文件称为PE+或PE32+。</p>
<h2 id="PE文件种类"><a href="#PE文件种类" class="headerlink" title="PE文件种类"></a>PE文件种类</h2><table>
<thead>
<tr>
<th>种类</th>
<th>主扩展名</th>
</tr>
</thead>
<tbody><tr>
<td>可执行系列</td>
<td>EXE,SCR</td>
</tr>
<tr>
<td>驱动程序系列</td>
<td>SYS,VXD</td>
</tr>
<tr>
<td>库系列</td>
<td>DLL,OCX,CPL,DRV</td>
</tr>
<tr>
<td>对象文件系列</td>
<td>OBJ</td>
</tr>
</tbody></table>
<p>OBJ是编译结果文件，除了OBJ其他文件都是可执行的。DLL和SYS虽然不能在Shell执行，但是可以通过调试器，服务等执行。</p>
<h2 id="PE头简介"><a href="#PE头简介" class="headerlink" title="PE头简介"></a>PE头简介</h2><p>PE文件头记录了PE文件中的所有数据的组织方式，它类似于一本书的目录，通过目录我们可以快速定位到某个具体的章节；通过PE文件头部分对某些数据结构的描述，我们也可以定位到那些不在文件头部的信息，比如导入表数据、导出表数据、资源表数据等。</p>
<p>拿加载配置数据的数据结构IMAGE_LOAD_CONFIG_DIRECTORY来说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMAGE_LOAD_CONFIG_DIRECTORY STRUCT</span><br><span class="line"></span><br><span class="line">Characteristics dd ? ;0000h-加载配置属性，一般为48h</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">SecurityCookie dd ?</span><br><span class="line"></span><br><span class="line">SEHandlerTable dd ? ;0040h-指向安全SEH异常处理函数列表</span><br><span class="line"></span><br><span class="line">SEHandlerCount dd ? ;0044h-列表中安全Handler的个数</span><br><span class="line"></span><br><span class="line">IMAGE_LOAD_CONFIG_DIRECTORY ENDS</span><br></pre></td></tr></table></figure>

<p>在这个结构体中，SEHandlerTable指向一个地址数组，该地址数组的个数由SEHandlerCount代替。地址的每一个值都是一个RVA（相对虚拟内存地址），RVA指向了结构化异常处理函数字节码。</p>
<p><img src="/2021/12/14/Windows/PE/PE%5Cimage-20211214012155322.png" alt="image-20211214012155322"></p>
<h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><h3 id="16位"><a href="#16位" class="headerlink" title="16位"></a>16位</h3><p>PE经历了从16位到32位的过渡，32位的PE文件都可以在16位系统兼容，然而两者结构的划分却不一致。</p>
<p>在16位系统下，PE结构可以大致划分为两部分：DOS头和冗余数据。DOS头可以划分为DOS MZ头和DOS Stub指令码</p>
<p><img src="/2021/12/14/Windows/PE/PE%5Cimage-20211214022748812.png" alt="image-20211214022748812"></p>
<p>DOS MZ头的定义如下</p>
<p><img src="/2021/12/14/Windows/PE/PE%5Cimage-20211214022912900.png" alt="image-20211214022912900"></p>
<p>加粗部分在16位系统下是没有定义的。</p>
<p>DOS Stub部分是该程序在DOS系统下运行的指令字节码。它的长度是不固定的，也导致了DOS头的长度不固定。</p>
<p>拿notepad.exe举例<img src="/2021/12/14/Windows/PE/PE%5Cimage-20211214023944837.png" alt="image-20211214023944837"></p>
<p>反汇编后可以看出DOS Stub的功能，这里是打印出字符串，我们可以通过更改DOS头来给PE文件修改和添加功能。<img src="/2021/12/14/Windows/PE/PE%5Cimage-20211214024135021.png" alt="image-20211214024135021"></p>
<h3 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h3><p>在32位的PE中，DOS头反而冗余数据（不参与运行）。但是DOS MZ 在32位PE也是必须的。因为在DOS MZ头中有一个字段非常重要，即IMAGE_DOS_HEADER.e_lfanew，没有它操作系统就定位不到标准的PE头部，可执行程序也就会被操作系统认为是非法的PE映像。</p>
<p>由于DOS头的长度不固定，e_lfanew显得格外有意义，该字段的值是一个相对偏移量和DOS MZ的基地址一起定位PE的起始位置。</p>
<p><code>PE_start=DOS MZ基地址+IMAGE_DOS_HEADER.e_lfanew</code></p>
<p>32位下PE基本格式如下</p>
<p><img src="/2021/12/14/Windows/PE/PE%5Cimage-20211214031117324.png" alt="image-20211214031117324"></p>
<p>DOS MZ头，DOS Stub，PE头，节表，四个部分组成了PE头部内容。节内容组成PE体内容，导入表、导出表、资源表、重定位表都在节内容中组织起来。</p>
<p>DOS MZ头的大小是64个字节，在数据目录表项为16时，PE头的大小是456个字节，具体大小由IMAGE_FILE_HEADER.SizeOfOptionalHeader决定。</p>
<p>节表，DOS Stub，和节内容的大小都是不固定的。其中，节表的不固定取决于节数目的不固定。每个节的描述信息则是个40字节的固定值，节表大小等于节的数量×40。节的数量由IMAGE_FILE_HEADER.NumberOfSections来定义。</p>
<h2 id="PE文件头部解析"><a href="#PE文件头部解析" class="headerlink" title="PE文件头部解析"></a>PE文件头部解析</h2><h3 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h3><p>如上所说，DOS头分为DOS MZ头IMAGE_DOS_HEADER和DOS Stub。</p>
<p><img src="/2021/12/14/Windows/PE/PE%5Cimage-20211214031647456.png" alt="image-20211214031647456"></p>
<p>DOS MZ头下面是DOS Stub，其内容随着链接所用的链接器不同而不同，PE没有对应的结构体。</p>
<h3 id="PE头"><a href="#PE头" class="headerlink" title="PE头"></a>PE头</h3><p>PE头IMAGE_NT_HEADERS</p>
<p>广义上的PE头，在标准的PE文件中其大小为456个字节</p>
<p><img src="/2021/12/14/Windows/PE/PE%5Cimage-20211214033711784.png" alt="image-20211214033711784"></p>
<h4 id="PE头标识"><a href="#PE头标识" class="headerlink" title="PE头标识"></a>PE头标识</h4><p>PE头标识Signature</p>
<p>紧随着DOS Stub之后，IMAGE_DOS_HEADER.e_lfanew指向的PE_start，内容固定为00 00 45 50</p>
<h4 id="标准PE头"><a href="#标准PE头" class="headerlink" title="标准PE头"></a>标准PE头</h4><p>标准PE头IMAGE_FILE_HEADER，微软官方文档称为COFF头（标准通用对象文件格式），用20个字节记录了PE的全局属性。</p>
<p><img src="/2021/12/14/Windows/PE/PE%5Cimage-20211214032956696.png" alt="image-20211214032956696"></p>
<blockquote>
<p>注释后的偏移基于IMAGE_NT_HEADERS头</p>
</blockquote>
<p>该结构常用于判断PE文件是EXE类型还是DLL类型，不但可以通过该结构得到PE文件中节的总量，还可以当成对节区信息进行遍历操作时的循环次数。</p>
<h4 id="拓展PE头"><a href="#拓展PE头" class="headerlink" title="拓展PE头"></a>拓展PE头</h4><p>扩展PE头IMAGE_OPTIONAL_HEADER32</p>
<p><img src="/2021/12/14/Windows/PE/PE%5Cimage-20211214033237547.png" alt="image-20211214033237547"></p>
<blockquote>
<p>注释后的偏移基于IMAGE_NT_HEADERS头</p>
</blockquote>
<p>文件执行时的<strong>入口地址</strong>、文件被操作系统装入内存后的默认基地址，以及节在磁盘和内存中的对齐单位等信息均可以在此结构中找到。对该结构中的某些数值的随意改动可能会造成PE文件的加载或运行失败。</p>
<h5 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h5><p>数据目录项IMAGE_DATA_DIRECTORY</p>
<p>IMAGE_OPTIONAL_HEADER32（扩展PE头）的最后一个字段，该字段定义了PE文件中出现的所有不同类型的数据的目录信息。如前所述，应用程序中的数据被按照用途分成很多种类，如导出表、导入表、资源、重定位表等，该结构就是用来描述这些不同类别的数据在文件（和内存）中的位置及大小。</p>
<p>数据目录定义了16中数据类型</p>
<p><img src="/2021/12/14/Windows/PE/PE%5Cimage-20211214034742543.png" alt="image-20211214034742543"></p>
<p>PE中使用了一种称作“数据目录项IMAGE_DATA_DIRECTORY”的数据结构来定义每种数据。该结构只有两个字段。</p>
<p><img src="/2021/12/14/Windows/PE/PE%5Cimage-20211214034836204.png" alt="image-20211214034836204"></p>
<blockquote>
<p>偏移基于IMAGE_NT_HEADERS头</p>
</blockquote>
<p>总的数据目录一共由16个相同的IMAGE_DATA_DIRECTORY结构连续排列在一起组成。</p>
<p>该数据目录的重要性体现在寻找特定类型的数据，如果查看PE中调用的DLL的函数，则需要从数据目录表的第2个元素获取导入表起始位置和大小，在根据VirtualAddress_1找到导入表字节码。</p>
<h4 id="节表项"><a href="#节表项" class="headerlink" title="节表项"></a>节表项</h4><p>节表项IMAGE_SECTION_HEADER</p>
<p>紧随在PE头后，每个节表项记录了PE中与某个特定的节有关的信息，如节的属性、节的大小、在文件和内存中的起始位置等。节表中节的数量由字段IMAGE_FILE_HEADER.NumberOfSections（标准PE头）来定义。</p>
<p><img src="/2021/12/14/Windows/PE/PE%5Cimage-20211214035717069.png" alt="image-20211214035717069"></p>
<blockquote>
<p>偏移是基于IMAGE_SECTION_HEADER头</p>
</blockquote>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>PE字段解析</title>
    <url>/2021/12/14/Windows/PE%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="PE字段解析"><a href="#PE字段解析" class="headerlink" title="PE字段解析"></a>PE字段解析</h1><p>本文是对PE头部字段的逐个解析，很无聊（</p>
<h2 id="PE头部字段"><a href="#PE头部字段" class="headerlink" title="PE头部字段"></a>PE头部字段</h2><p>IMAGE_NT_HEADER，由三个字段构成。</p>
<h4 id="Signature"><a href="#Signature" class="headerlink" title=".Signature"></a>.Signature</h4><p>就是”P”，”E”加上两个0，也是PE这个称呼的由来。如果更改其中的任何一个字节，操作系统就无法把该文件识别为正确的PE文件。</p>
<h4 id="FileHeader"><a href="#FileHeader" class="headerlink" title=".FileHeader"></a>.FileHeader</h4><p>+0004h，结构体。该结构指向IMAGE_FILE_HEADER，由于PE扩展自通用COFF规范，该字段在官方文档中被称为标准COFF头。</p>
<h4 id="OptionalHeader"><a href="#OptionalHeader" class="headerlink" title=".OptionalHeader"></a>.OptionalHeader</h4><p>+0018h，结构体。该结构指向IMAGE_OPTIONAL_HEADER32。Windows操作系统可执行文件的大部分特性均在这个结构里呈现。</p>
<p>因为在符合COFF规范的”.obj”目标文件中该部分并不存在，所以该部分被称为OptionalHeader（可选的头部信息，简称“可选头”），它是操作系统映像文件所独有的头部信息。</p>
<p>可选头又分为两部分，前10个字段原属于COFF，用来加载和运行一个可执行文件；后21个字段则是通过链接器追加的。它们作为PE扩展的部分，用z于描述可执行文件的一些信息，供PE加载器加载使用。</p>
<h3 id="IMAGE-FILE-HEADER字段解析"><a href="#IMAGE-FILE-HEADER字段解析" class="headerlink" title="IMAGE_FILE_HEADER字段解析"></a>IMAGE_FILE_HEADER字段解析</h3><h4 id="Machine"><a href="#Machine" class="headerlink" title=".Machine"></a>.Machine</h4><p>+0004h，单字，指定PE运行的平台。由于Windows最初被设计为可以运行在Intel、Sun、Dec、IBM等多种硬件平台上，或者能模拟这些平台的软件环境中，而不同的硬件平台其指令的机器码不相同，因此为不同平台编译的EXE文件是无法通用的。</p>
<p>MASM32汇编可以用<code>.386</code>指定inter 386平台</p>
<p>相关数值对应的处理器如下</p>
<p><img src="/2021/12/14/Windows/PE%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90/image-20211214160557314.png" alt="image-20211214160557314"></p>
<p>x64下notepad.exe的IMAGE_FILE_HEADER.Machine值</p>
<p><img src="/2021/12/14/Windows/PE%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90/image-20211214160631279.png" alt="image-20211214160631279"></p>
<h4 id="NumberOfSections"><a href="#NumberOfSections" class="headerlink" title=".NumberOfSections"></a>.NumberOfSections</h4><p>+0006h，单字。文件中存在的节的总数。可以有0个节，但数值不能小于1，也不能超过96。如果数值是0，操作系统会提示不是有效程序。在PE中增加或删除节必须修改此处的值。并且，PE节数必须和<strong>内存中的节</strong>相同，否则装载错误。</p>
<h4 id="TimeDataStamp"><a href="#TimeDataStamp" class="headerlink" title=".TimeDataStamp"></a>.TimeDataStamp</h4><p>+0008h，双字，时间戳。低32位存放的值是自1970年1月1日00:00时开始到创建时间为止的总秒数。与操作系统文件属性里看到的三个时间（创建时间、修改时间、访问时间）没有关联，可以随意修改。</p>
<h4 id="PointerToSymbolTable"><a href="#PointerToSymbolTable" class="headerlink" title=".PointerToSymbolTable"></a>.PointerToSymbolTable</h4><p>+000Ch，双字。COFF符号表的文件偏移。如果不存在COFF符号表，此值为0。对于映像文件来说，此值为0，因为微软已经不在PE中使用COFF调试信息。</p>
<h4 id="SizeOfOptionalHeader"><a href="#SizeOfOptionalHeader" class="headerlink" title=".SizeOfOptionalHeader"></a>.SizeOfOptionalHeader</h4><p>+0014h，单字。指定IMAGE_OPTINOAL_HEADER32的长度，32位PE默认情况00e2h；64位默认为00F0h。</p>
<p>可以自己定义这个值的大小，不过需要注意两点：</p>
<p>1）更改完以后，需要自行将文件中IMAGE_OPITONAL_HEADER32的大小扩充为你指定的值（一般以0补足）。</p>
<p>2）扩充完以后，要维持文件中的对齐特性（比如此处增加了8个字节后，一定在后面相应地删除8个字节，以保证.text节起始位置处于0400h）。</p>
<h4 id="Characteristics"><a href="#Characteristics" class="headerlink" title=".Characteristics"></a>.Characteristics</h4><p>+0016h，单字，文件属性标志字段。不同位定义了不同文件属性。</p>
<p><img src="/2021/12/14/Windows/PE%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90/image-20211214162935175.png" alt="image-20211214162935175"></p>
<p>当第10位为1时，如果此映像文件在可移动存储介质上，那么加载器将完全加载它并把它复制到内存交换文件中。</p>
<p>当第11位为1时，如果此映像文件在网络上，那么加载器也将完全加载它并把它复制到内存交换文件中。</p>
<p>这是一个很重要的字段，不同的定义将影响系统对文件的装入方式。</p>
<h3 id="IMAGE-OPTIONAL-HEADER32"><a href="#IMAGE-OPTIONAL-HEADER32" class="headerlink" title="IMAGE_OPTIONAL_HEADER32"></a>IMAGE_OPTIONAL_HEADER32</h3><h4 id="Magic"><a href="#Magic" class="headerlink" title=".Magic"></a>.Magic</h4><p>+0018h，单字。魔术字，说明文件类型。</p>
<p>如果为010BH，则表示该文件为PE32；如果为0107h，则表示文件为ROM映像；如果为020BH，则表示该文件为PE32+，即64位下的PE文件。</p>
<h4 id="MajorLinkerVersion和-MinorLinkerVersion"><a href="#MajorLinkerVersion和-MinorLinkerVersion" class="headerlink" title=".MajorLinkerVersion和.MinorLinkerVersion"></a>.MajorLinkerVersion和.MinorLinkerVersion</h4><p>+001ah，单字。指定链接器版本号，对执行没有任何影响。</p>
<h4 id="SizeOfCode"><a href="#SizeOfCode" class="headerlink" title=".SizeOfCode"></a>.SizeOfCode</h4><p>+001ch，双字。所有代码节的总和（以字节计算）该大小是基于文件对齐后的大小，而非内存对齐后的大小。内存对齐的大小基于另一个字段.SizeOfImage。另外：判断某个节是否包含代码的方法不是根据节的属性中是否含有IMAGE_SCN_MEM_EXECUTE标志，而是根据节的属性中是否含有IMAGE_SCN_CNT_CODE标志。</p>
<h4 id="SizeOfInitializedData和-SizeOfUninitializedData"><a href="#SizeOfInitializedData和-SizeOfUninitializedData" class="headerlink" title=".SizeOfInitializedData和.SizeOfUninitializedData"></a>.SizeOfInitializedData和.SizeOfUninitializedData</h4><p>+0020h，双字。包含已经初始化的的数据的节的总大小。</p>
<p>+0024h，双字。。包含所有未初始化的数据的节的总大小。</p>
<p>未初始化在文件中不占有空间，但是在加载的内存中，PE应该为数据分配适当大小的虚拟地址空间。</p>
<h4 id="AddressOfEntryPoint"><a href="#AddressOfEntryPoint" class="headerlink" title=".AddressOfEntryPoint"></a>.AddressOfEntryPoint</h4><p>+0028h，双字。记录程序启动代码距离PE加载后的起始位置的RVA，对于一般程序映像来说，它就是启动地址；对于设备驱动程序来说，它是初始化函数的地址。入口点对于DLL来说是可选的，如果不存在入口点，这个字段必须设置为0。</p>
<p>病毒，加密程序，补丁可以通过劫持这里的值来让程序运行其他用途的代码字段。</p>
<h4 id="BaseOfCode和-BaseOfData"><a href="#BaseOfCode和-BaseOfData" class="headerlink" title=".BaseOfCode和.BaseOfData"></a>.BaseOfCode和.BaseOfData</h4><p>+002Ch，双字。记录代码节到映像基址的RVA，代码节一般紧随在PE后，名称为“.text”</p>
<p>+0030h，双字。记录数据节到映像基址的RVA，数据节一般位于文件末尾，名称为“.data”</p>
<h4 id="ImageBase"><a href="#ImageBase" class="headerlink" title=".ImageBase"></a>.ImageBase</h4><p>+0034h，双字。该字段指出了PE映像的优先装入地址。链接器在产生可执行文件的时候，是对应这个地址来生成机器码的。如果操作系统也是按照这个地址加载机器码到内存中，那么指令中的许多重定位信息就不需要修改了，这样运行速度就会更快一些。</p>
<p>在链接的时候，可以使用参数”-base”来指定优先装入的地址，如果不指定，那么链接器默认装入EXE的地址就是0x00400000。而相对于DLL文件来说，它默认优先装入地址则是0x10000000。如果一个进程用到了多个DLL文件，其装入地址可能会发生冲突。PE加载器会调整其中的地址，使所有的DLL文件都能被正确装入。所以，不要错误地认为内存中动态链接库的基地址和其文件头字段IAMGE_OPTIONAL_HEADER32.ImageBase指定的完全一样。</p>
<p>我们可以自己来定义这个值，但是第一，取值不能超出边界，即取的值必须在进程地址空间中；第二，该值必须是64KB的整数倍。</p>
<h4 id="SectionAlignment和-FileAlignment"><a href="#SectionAlignment和-FileAlignment" class="headerlink" title=".SectionAlignment和.FileAlignment"></a>.SectionAlignment和.FileAlignment</h4><p>+0038h，双字。内存中节的对齐粒度</p>
<p>内存中的数据存取以页面为单位。Win32的页面大小是4KB，所以Win32 PE中节的内存对齐粒度一般都选择4KB大小。十六进制表示为01000h。(和16位汇编要从偶地址取数道理类似)</p>
<p>SectionAlignment必须大于或等于FileAlignment</p>
<p>+003ch，双字。文件中节的对齐粒度，同样也是为了提高文件从磁盘加载的效率。</p>
<p>Windows用来组织硬盘的所有文件系统都是基于簇（分配单元）的，每个簇包含几个物理扇区。扇区是磁盘物理存取的最小单位。簇越大，磁盘存储信息的容量就越大，但存取所花费的时间也越长。通常情况下，Windows会选择使用512字节的簇大小来格式化分区，最大可以达到4KB。</p>
<h4 id="版本号相关字段"><a href="#版本号相关字段" class="headerlink" title="版本号相关字段"></a>版本号相关字段</h4><p>这部分字段相对不是很重要</p>
<p>.MajorOperatingSystemVersion</p>
<p>.MinorOperatingSystemVersion</p>
<p>+0040h，两个单字，标识操作系统的主版本号和次版本号</p>
<p>.MajorImageVersion</p>
<p>.MinorImageVersion</p>
<p>+0044h，两个字。PE文件映像的版本号。</p>
<p>.MajorSubsystemVersion</p>
<p>.MinorSubsystemVersion</p>
<p>+0048h，两个字。运行所需子系统版本号</p>
<p>.Win32VersionValue</p>
<p>+004ch，双字，子系统版本。暂时未用，必须设置为0。</p>
<h4 id="SizeOfImage和-SizeOfHeaders"><a href="#SizeOfImage和-SizeOfHeaders" class="headerlink" title=".SizeOfImage和.SizeOfHeaders"></a>.SizeOfImage和.SizeOfHeaders</h4><p>+0050h，双字。内存中整个PE文件的映射尺寸，可以比实际值大。按照1000h对齐。</p>
<p>+0054h，双字。所有头+节表按照文件对齐粒度对齐后的大小（即含补足的0），按照200h对齐。</p>
<h4 id="CheckSum"><a href="#CheckSum" class="headerlink" title=".CheckSum"></a>.CheckSum</h4><p>+0058h，双字。校验和，在大多数PE中，该值是0。在一些内核模式的驱动程序和系统DLL中，该值则是必须存在且是正确的。</p>
<h4 id="Subsystem"><a href="#Subsystem" class="headerlink" title=".Subsystem"></a>.Subsystem</h4><p>+005ch，单字。指定使用界面的子系统。主要选择是GUI和CUI。</p>
<p><img src="/2021/12/14/Windows/PE%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90/image-20211215005501888.png" alt="image-20211215005501888"></p>
<h4 id="DllCharacteristics"><a href="#DllCharacteristics" class="headerlink" title=".DllCharacteristics"></a>.DllCharacteristics</h4><p>+005eh，单字。DLL文件属性。是一个标志集，定义PE文件装载时的特性</p>
<p><img src="/2021/12/14/Windows/PE%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90/image-20211215005655365.png" alt="image-20211215005655365"></p>
<h4 id="SizeOfStackReserve和-SizeOfStackCommit"><a href="#SizeOfStackReserve和-SizeOfStackCommit" class="headerlink" title=".SizeOfStackReserve和.SizeOfStackCommit"></a>.SizeOfStackReserve和.SizeOfStackCommit</h4><p>+0060h，双字，初始化时保留栈的大小。该字段表示为初始线程的栈而保留的虚拟内存数量，然而并不是留出的所有虚拟内存都可以做栈（真正的栈大小由下一个字段SizeOfStackCommit决定）。默认为0x100000。</p>
<p>+0064h，双字，初始化时实际提交的栈大小。保证初始线程的栈实际占用内存空间的大小。默认是一页，1MB。</p>
<h4 id="SizeOfHeapReserve和-SizeOfHeapCommit"><a href="#SizeOfHeapReserve和-SizeOfHeapCommit" class="headerlink" title=".SizeOfHeapReserve和.SizeOfHeapCommit"></a>.SizeOfHeapReserve和.SizeOfHeapCommit</h4><p>+0068h，双字。</p>
<p>+006ch，双字。大体上和前面两个字段相似，这两个字段定义堆的大小。</p>
<h4 id="LoaderFlags"><a href="#LoaderFlags" class="headerlink" title=".LoaderFlags"></a>.LoaderFlags</h4><p>+0070h，双字，加载标志。</p>
<h4 id="NumberOfRvaAndSize和-DataDirectory"><a href="#NumberOfRvaAndSize和-DataDirectory" class="headerlink" title=".NumberOfRvaAndSize和.DataDirectory"></a>.NumberOfRvaAndSize和.DataDirectory</h4><p>一篇对.NumberOfRvaAndSize功能的研究：</p>
<p><a href="https://bbs.pediy.com/thread-76032.htm">https://bbs.pediy.com/thread-76032.htm</a></p>
<p>+0074h，双字，定义数据目录的数量。一般为16，具体数量由.SizeOfOptionalHeaders决定（这里有疑惑）。实际应用中可以取2～16的值。</p>
<p>+0078h，结构。由16个IMAGE_DATA_DIRECTORY结构线性排列而成，用于定义PE中的16种不同类别的数据所在的位置和大小。</p>
<h5 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h5><p>如上所说，一般会定义16种数据类型</p>
<table>
<thead>
<tr>
<th>类别编号</th>
<th>名称</th>
<th>所在节名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>导出数据</td>
<td>.edata</td>
<td>包含一些可被其他exe访问的符号相关信息，如资源和导出函数</td>
</tr>
<tr>
<td>1</td>
<td>导入数据</td>
<td>.idata</td>
<td>包含PE映像所有导入的符号</td>
</tr>
<tr>
<td>2</td>
<td>异常表数据</td>
<td>.pdata</td>
<td>该节是由用于异常处理的函数表项组成的数组</td>
</tr>
<tr>
<td>3</td>
<td>资源数据</td>
<td>.rsrc</td>
<td>多层的二叉排序树，节点指向各种资源。可以有2^31^层，经常使用类型层，名称层，语言代码层</td>
</tr>
<tr>
<td>4</td>
<td>属性证书数据</td>
<td></td>
<td>由一组连续的按八进制字（从任意字节边界开始的16个连续字节）边界对齐的属性证书表项组成，每个属性证书表项指向WIN_CERTIFICATE结构，验证PE文件是否被修改</td>
</tr>
<tr>
<td>5</td>
<td>基址重定位信息</td>
<td>.reloc</td>
<td>基址重定位表包含了映像中所有需要重定位的内容。</td>
</tr>
<tr>
<td>6</td>
<td>调试数据</td>
<td>.debug</td>
<td>指向IMAGE_DEBUG_DIRECTORY结构数组。其中的每个元素都描述了PE中的一些调试信息</td>
</tr>
<tr>
<td>7</td>
<td>预留</td>
<td>0</td>
<td>必须为0</td>
</tr>
<tr>
<td>8</td>
<td>Global Ptr</td>
<td></td>
<td>存储在全局指针寄存器中的一个值。</td>
</tr>
<tr>
<td>9</td>
<td>线程本地存储数据</td>
<td>.tls</td>
<td>数据对象对应于运行相应代码的单个线程</td>
</tr>
<tr>
<td>10</td>
<td>加载配置信息</td>
<td>包含保留的SEH技术</td>
<td>提供安全的结构化异常处理程序列表，操作系统在进行异常处理时要用到这些异常处理程序</td>
</tr>
<tr>
<td>11</td>
<td>绑定导入数据</td>
<td></td>
<td>优化导入信息，由程序员或链接器代替Windows加载器完成了一部分对导入表的处理工作（在加载时）</td>
</tr>
<tr>
<td>12</td>
<td>IAT</td>
<td></td>
<td>导入表的一部分，这个双字数组里定义了所有导入函数的VA，程序可以直接通过跳转指令跳转到该VA处执行</td>
</tr>
<tr>
<td>13</td>
<td>延迟导入数据</td>
<td></td>
<td>为延迟加载提供统一的访问机制</td>
</tr>
<tr>
<td>14</td>
<td>CLR数据</td>
<td>.cormeta</td>
<td>.NET框架的一个重要组成部分，所有基于.NET框架开发的程序，其初始化部分都是通过访问这部分定义而实现的。PE加载时将通过该结构加载代码托管机制需要的所有动态链接库文件</td>
</tr>
<tr>
<td>15</td>
<td>预留</td>
<td>未定义</td>
<td>未定义</td>
</tr>
</tbody></table>
<h2 id="PE体字段（节表项）"><a href="#PE体字段（节表项）" class="headerlink" title="PE体字段（节表项）"></a>PE体字段（节表项）</h2><h3 id="IMAGE-SECTION-HEADER"><a href="#IMAGE-SECTION-HEADER" class="headerlink" title="IMAGE_SECTION_HEADER"></a>IMAGE_SECTION_HEADER</h3><p>每个节表都有类似的结构完成节表的定义。</p>
<h4 id="Name1"><a href="#Name1" class="headerlink" title=".Name1"></a>.Name1</h4><p>+0000h，8字节。一般以一个以“\0”结尾的ASCII来表示节的名称。</p>
<h4 id="MISC"><a href="#MISC" class="headerlink" title=".MISC"></a>.MISC</h4><p>+0008h，双字。联合型的数据，这是节的数据在没有对齐前的真实尺寸，不过很多PE文件里该值并不准确。</p>
<h4 id="VirtualAddress"><a href="#VirtualAddress" class="headerlink" title=".VirtualAddress"></a>.VirtualAddress</h4><p>+000ch，双字，节区的RVA。</p>
<h4 id="SizeOfRawData"><a href="#SizeOfRawData" class="headerlink" title=".SizeOfRawData"></a>.SizeOfRawData</h4><p>+0010h，双字，节对齐后的尺寸，一般是200h。</p>
<h4 id="PointerToRawData"><a href="#PointerToRawData" class="headerlink" title=".PointerToRawData"></a>.PointerToRawData</h4><p>+0014h，双字，节区其实数据在文件中的偏移。</p>
<h4 id="PointerToRelocations"><a href="#PointerToRelocations" class="headerlink" title=".PointerToRelocations"></a>.PointerToRelocations</h4><p>+0018h，双字，“.obj”中使用，指向重定位表的指针</p>
<h4 id="PointerToLinenumbers"><a href="#PointerToLinenumbers" class="headerlink" title=".PointerToLinenumbers"></a>.PointerToLinenumbers</h4><p>+001ch，双字，行号表的位置</p>
<h4 id="NumberOfRelocations"><a href="#NumberOfRelocations" class="headerlink" title=".NumberOfRelocations"></a>.NumberOfRelocations</h4><p>+0020h，单字。重定位表的个数（在OBJ文件中使用）</p>
<h4 id="NumberOfLinenumbers"><a href="#NumberOfLinenumbers" class="headerlink" title=".NumberOfLinenumbers"></a>.NumberOfLinenumbers</h4><p>+0022h，单字。行号表中行号的数量。</p>
<h4 id="Characteristics-1"><a href="#Characteristics-1" class="headerlink" title=".Characteristics"></a>.Characteristics</h4><p>+0024h，双字。节的属性。这个字段很重要，这是节的属性标志字段。</p>
<p><img src="/2021/12/14/Windows/PE%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90/image-20211215021048562.png" alt="image-20211215021048562"></p>
<p>代码节的属性一般为60000020h，也就是可执行、可读和“节中包含代码”；数据节的属性一般为c0000040h，也就是可读、可写和“包含已初始化数据”；而常量节（对应源代码中的.const段）的属性为40000040h，也就是可读和“包含已初始化数据”；资源节的属性和常量节的属性一般是相同的。</p>
<p>当然，节属性的定义不一定必须是这些值。比如，当PE文件被压缩工具压缩以后，包含代码的节往往被同时设置成具有可执行、可读和可写属性，因为解压部分需要将解压后的代码回写到代码段中。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>PE解析器简单实现</title>
    <url>/2022/03/23/Windows/PE%E8%A7%A3%E6%9E%90%E5%99%A8%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="PE解析器的简单实现"><a href="#PE解析器的简单实现" class="headerlink" title="PE解析器的简单实现"></a>PE解析器的简单实现</h2><p>写东西之前一定要去网上查资料（ 我上一个版本不知道可以拿预定义好的结构体来读取数据，导致自己按字节读取了好久。。。</p>
<p>使用的头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>创建一个PE解析器类，首先考虑到PE文件解析时候要多次检测，设置一个Check（）成员函数，不同组分的打印各自设定函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PEInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">PEInfo</span>(<span class="keyword">const</span> <span class="keyword">char</span>* filename);</span><br><span class="line">	~<span class="built_in">PEInfo</span>();</span><br><span class="line">	<span class="function">BOOL <span class="title">Check</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span></span></span><br><span class="line"><span class="function">		BOOL <span class="title">FileCheck</span><span class="params">(<span class="keyword">const</span> PEInfo&amp; pe)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span></span></span><br><span class="line"><span class="function">		BOOL <span class="title">MapCheck</span><span class="params">(<span class="keyword">const</span> PEInfo&amp; pe)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span></span></span><br><span class="line"><span class="function">		BOOL <span class="title">ImageCheck</span><span class="params">(<span class="keyword">const</span> PEInfo&amp; pe)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span></span></span><br><span class="line"><span class="function">		BOOL <span class="title">PECheck</span><span class="params">(<span class="keyword">const</span> PEInfo&amp; pe)</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">NTHeaderShow</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">SectionTableShow</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">ImportTableShow</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">ExportTableShow</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span></span></span><br><span class="line"><span class="function">		PIMAGE_NT_HEADERS	<span class="title">pNTGet</span><span class="params">(<span class="keyword">const</span> PEInfo&amp; pe)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PEhand</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		HANDLE hFile;</span><br><span class="line">		HANDLE hMapping;</span><br><span class="line">		LPVOID Imagebase;</span><br><span class="line">	&#125;PEh;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pNT后面会多次使用，我们设置一个非成员的友元函数接口，实际上设置到PEhand或许会更好？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PEInfo::<span class="built_in">PEInfo</span>(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;PEh.hFile = <span class="built_in">CreateFileA</span>(filename, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">this</span>-&gt;PEh.hMapping = <span class="built_in">CreateFileMappingA</span>(<span class="keyword">this</span>-&gt;PEh.hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">this</span>-&gt;PEh.Imagebase = <span class="built_in">MapViewOfFile</span>(<span class="keyword">this</span>-&gt;PEh.hMapping, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置构造函数，Imagebase的使用尤其频繁。</p>
<p>首先实现检测</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PEInfo::Check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FileCheck</span>(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="built_in">MapCheck</span>(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="built_in">ImageCheck</span>(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="built_in">PECheck</span>(*<span class="keyword">this</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;This File is a PE File&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里分别进行了文件打开，文件映射，和PE格式检测，也可以放到PEInfo的构造函数进行自动检测</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MapCheck</span><span class="params">(<span class="keyword">const</span> PEInfo&amp; pe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!pe.PEh.hMapping)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;MAPPING CREATE FAILED!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">ImageCheck</span><span class="params">(<span class="keyword">const</span> PEInfo&amp; pe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!pe.PEh.Imagebase)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;FILE MAPPING FAILED!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">FileCheck</span><span class="params">(<span class="keyword">const</span> PEInfo&amp; pe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!pe.PEh.hFile)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;FILE OPEN FAILED!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">PECheck</span><span class="params">(<span class="keyword">const</span> PEInfo&amp; pe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIMAGE_DOS_HEADER	pDos = (PIMAGE_DOS_HEADER)pe.PEh.Imagebase;</span><br><span class="line">	<span class="keyword">if</span> (pDos-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	PIMAGE_NT_HEADERS pNT = (PIMAGE_NT_HEADERS)((DWORD)pDos + pDos-&gt;e_lfanew);</span><br><span class="line">	<span class="keyword">if</span> (pNT-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于涉及到多次的打印，这里用可变参数模板设计了一套泛型的打印</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ..._Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Printer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Printer</span>&lt;</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Printer</span>&lt;</span>_T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> _T&amp; arg)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; arg &lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _T,<span class="keyword">typename</span> ..._Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Printer</span>&lt;</span>_T,_Ts...&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> _T&amp; arg, <span class="keyword">const</span> _Ts &amp;...args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout&lt;&lt;std::<span class="built_in">setw</span>(<span class="number">30</span>)&lt;&lt;std::<span class="built_in">setbase</span>(<span class="number">16</span>)&lt;&lt;std::showbase&lt;&lt;std::uppercase&lt;&lt; arg &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		Printer&lt;_Ts...&gt;::<span class="built_in">Print</span>(args...);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _T,<span class="keyword">typename</span> ..._Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> _T &amp;arg,<span class="keyword">const</span> _Ts &amp;...args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Printer&lt;_T,_Ts...&gt;::<span class="built_in">Print</span>(arg,args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PIMAGE_NT_HEADERS <span class="title">pNTGet</span><span class="params">(<span class="keyword">const</span> PEInfo&amp; pe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIMAGE_DOS_HEADER pDos = <span class="literal">nullptr</span>;</span><br><span class="line">	PIMAGE_NT_HEADERS pNT = <span class="literal">nullptr</span>;</span><br><span class="line">	pDos = (PIMAGE_DOS_HEADER)pe.PEh.Imagebase;</span><br><span class="line">	pNT = (PIMAGE_NT_HEADERS)((DWORD)pDos + pDos-&gt;e_lfanew);</span><br><span class="line">	<span class="keyword">return</span> pNT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NT头指针的获取，在后面的实现中我们多次使用NT头来定位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PEInfo::NTHeaderShow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIMAGE_NT_HEADERS  pNT = <span class="built_in">pNTGet</span>(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;Signature:\t\t&quot;</span>, pNT-&gt;Signature);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;Machine:\t\t&quot;</span>, pNT-&gt;FileHeader.Machine);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;NumberOfSection:\t\t&quot;</span>, pNT-&gt;FileHeader.NumberOfSections);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;TimeDataStamp:\t\t&quot;</span>, pNT-&gt;FileHeader.TimeDateStamp);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;SizeOfOptionalHeader:\t\t&quot;</span>, pNT-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;Characteristics:\t\t&quot;</span>, pNT-&gt;FileHeader.Characteristics);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;-----------------可选头-----------------&quot;</span>);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;Magic:\t\t&quot;</span>, pNT-&gt;OptionalHeader.Magic);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;AddressOfEntryPoint:\t\t&quot;</span>, pNT-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;ImageBase:\t\t&quot;</span>, pNT-&gt;OptionalHeader.ImageBase);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;SectionAlignment:\t\t&quot;</span>, pNT-&gt;OptionalHeader.SectionAlignment);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;FileAlignment:\t\t&quot;</span>, pNT-&gt;OptionalHeader.FileAlignment);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;SizeOfImage:\t\t&quot;</span>, pNT-&gt;OptionalHeader.SizeOfImage);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;SizeOfHeader:\t\t&quot;</span>, pNT-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;Subsystem:\t\t&quot;</span>, pNT-&gt;OptionalHeader.Subsystem);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;NumberOfRvaAndSizes:\t\t&quot;</span>, pNT-&gt;OptionalHeader.NumberOfRvaAndSizes);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;SizeOfImage:\t\t&quot;</span>, pNT-&gt;OptionalHeader.SizeOfImage);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;SizeOfHeader:\t\t&quot;</span>, pNT-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;Subsystem:\t\t&quot;</span>, pNT-&gt;OptionalHeader.Subsystem);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;---------------数据目录表---------------&quot;</span>);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;Export表的地址:\t\t&quot;</span>, pNT-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].VirtualAddress);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;Export的Size:\t\t&quot;</span>, pNT-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].Size);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;Import的地址:\t\t&quot;</span>, pNT-&gt;OptionalHeader.DataDirectory[<span class="number">1</span>].VirtualAddress);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;Import的Size:\t\t&quot;</span>, pNT-&gt;OptionalHeader.DataDirectory[<span class="number">1</span>].Size);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;Resource的地址:\t\t&quot;</span>, pNT-&gt;OptionalHeader.DataDirectory[<span class="number">2</span>].VirtualAddress);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;Resource的Size:\t\t&quot;</span>, pNT-&gt;OptionalHeader.DataDirectory[<span class="number">2</span>].Size);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;Reloc表的地址:\t\t&quot;</span>, pNT-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].VirtualAddress);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;Reloc的Size:\t\t&quot;</span>, pNT-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].Size);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;TLS表的地址:\t\t&quot;</span>, pNT-&gt;OptionalHeader.DataDirectory[<span class="number">9</span>].VirtualAddress);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;TLS的Size:\t\t&quot;</span>, pNT-&gt;OptionalHeader.DataDirectory[<span class="number">9</span>].Size);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;IAT的地址:\t\t&quot;</span>, pNT-&gt;OptionalHeader.DataDirectory[<span class="number">12</span>].VirtualAddress);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;IAT的Size:\t\t&quot;</span>, pNT-&gt;OptionalHeader.DataDirectory[<span class="number">12</span>].Size);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;----------------------------------------- &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很麻烦的打印（NT头）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PEInfo::SectionTableShow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIMAGE_NT_HEADERS pNT = <span class="built_in">pNTGet</span>(*<span class="keyword">this</span>);</span><br><span class="line">	PIMAGE_SECTION_HEADER pSH = <span class="keyword">reinterpret_cast</span>&lt;PIMAGE_SECTION_HEADER&gt;(<span class="built_in">IMAGE_FIRST_SECTION</span>(pNT));</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;-----------------节区表------------------&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pNT-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Print</span>(<span class="string">&quot;Name:\t\t&quot;</span>, pSH-&gt;Name);<span class="comment">//8位的ASCii码，&#x27;.&#x27;开始‘ ’结尾，如果带有$的会被合并</span></span><br><span class="line">		<span class="built_in">Print</span>(<span class="string">&quot;VirtualSize:\t\t&quot;</span>, pSH-&gt;Misc.VirtualSize);<span class="comment">//对齐前区块大小</span></span><br><span class="line">		<span class="built_in">Print</span>(<span class="string">&quot;VirtualAddress:\t\t&quot;</span>, pSH-&gt;VirtualAddress);</span><br><span class="line">		<span class="built_in">Print</span>(<span class="string">&quot;SizeOfRawData:\t\t&quot;</span>, pSH-&gt;SizeOfRawData);<span class="comment">//磁盘所占空间</span></span><br><span class="line">		<span class="built_in">Print</span>(<span class="string">&quot;PointerToRawData:\t\t&quot;</span>, pSH-&gt;PointerToRawData);<span class="comment">//更有意义</span></span><br><span class="line">		<span class="built_in">Print</span>(<span class="string">&quot;Characteristics:\t\t&quot;</span>, pSH-&gt;Characteristics);</span><br><span class="line">		<span class="built_in">Print</span>(<span class="string">&quot;------------------------------------------&quot;</span>);</span><br><span class="line">		pSH++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印SectionTable</p>
<p>接下来是打印输入输出表，在这之前我们先定义一个RVATORAW函数，方便后续操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">RVATORAW</span><span class="params">(DWORD RVA, <span class="keyword">const</span> PEInfo&amp; pe)</span> </span>&#123;</span><br><span class="line">	DWORD RAW = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> pNT = <span class="built_in">pNTGet</span>(pe);</span><br><span class="line">	PIMAGE_OPTIONAL_HEADER pOH = &amp;(pNT-&gt;OptionalHeader);</span><br><span class="line">	<span class="keyword">auto</span> pSH = <span class="keyword">reinterpret_cast</span>&lt;PIMAGE_SECTION_HEADER&gt;(<span class="built_in">IMAGE_FIRST_SECTION</span>(pNT));</span><br><span class="line">	<span class="keyword">if</span> (RVA &lt;= pOH-&gt;SizeOfHeaders)</span><br><span class="line">		<span class="keyword">return</span> RVA;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pNT-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (RVA &gt;= pSH[i].VirtualAddress &amp;&amp; RVA &lt;= pSH[i].VirtualAddress + pSH[i].Misc.VirtualSize)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> RVA - pSH[i].VirtualAddress + pSH[i].PointerToRawData;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> RAW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RAW = RVA - VA +pointertoraw</p>
<p>打印输入表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PEInfo::ImportTableShow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;\t\t\t\t\t-----------------导入表-----------------&quot;</span>);</span><br><span class="line">	<span class="keyword">auto</span> pNT = <span class="built_in">pNTGet</span>(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">auto</span> pDATA_IMT = <span class="keyword">reinterpret_cast</span>&lt;PIMAGE_DATA_DIRECTORY&gt;(pNT-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_IMPORT);</span><br><span class="line">	<span class="keyword">auto</span> pIMT = <span class="keyword">reinterpret_cast</span>&lt;PIMAGE_IMPORT_DESCRIPTOR&gt;((<span class="built_in">RVATORAW</span>(pDATA_IMT-&gt;VirtualAddress, *<span class="keyword">this</span>)+ (DWORD)PEh.Imagebase));</span><br><span class="line">	<span class="keyword">while</span> (pIMT-&gt;FirstThunk)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Print</span>(<span class="string">&quot;\n\n-----FILE:\t\t&quot;</span>, (<span class="keyword">char</span>*)(<span class="built_in">RVATORAW</span>(pIMT-&gt;Name,*<span class="keyword">this</span>)+ (DWORD)PEh.Imagebase),<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">		<span class="keyword">auto</span> pDATA_IAT = <span class="keyword">reinterpret_cast</span>&lt;PIMAGE_DATA_DIRECTORY&gt;(pNT-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_IAT);</span><br><span class="line">		<span class="keyword">auto</span> pIAT = <span class="keyword">reinterpret_cast</span>&lt;PIMAGE_THUNK_DATA&gt;((<span class="built_in">RVATORAW</span>(pDATA_IAT-&gt;VirtualAddress, *<span class="keyword">this</span>) + (DWORD)PEh.Imagebase));</span><br><span class="line">		<span class="keyword">for</span>(;pIAT-&gt;u1.Ordinal != <span class="number">0</span>;pIAT++)</span><br><span class="line">		&#123;</span><br><span class="line">			PIMAGE_IMPORT_BY_NAME pName = (PIMAGE_IMPORT_BY_NAME)(<span class="built_in">RVATORAW</span>(pIAT-&gt;u1.AddressOfData, *<span class="keyword">this</span>) + (DWORD)PEh.Imagebase);</span><br><span class="line">			<span class="built_in">Print</span>(<span class="string">&quot;FunctionName:\t\t&quot;</span>, pName-&gt;Name, <span class="string">&quot;FunctionHint:\t\t&quot;</span>, pName-&gt;Hint);</span><br><span class="line">		&#125;</span><br><span class="line">		pIMT++;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>输出表类似，不再演示。</p>
<p>很容易出错的地方是输出表打印时候的几处RVATORAW转换,区分好数据具体代表什么，不然就会和我一样调到凌晨4点（</p>
<p>主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in"><span class="keyword">sizeof</span></span>(argv[<span class="number">1</span>]) &gt; <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">PEInfo <span class="title">PEh</span><span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">		PEh.<span class="built_in">NTHeaderShow</span>();</span><br><span class="line">		PEh.<span class="built_in">SectionTableShow</span>();</span><br><span class="line">		PEh.<span class="built_in">ImportTableShow</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Input a correct filename plesae!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然说已经写过一遍PE解析器了，但是用C++尝试不同风格来进行编程区别还是挺大的。初学C++，很多地方做的不是很合理，整体的设计也不完善（虽然能用了），感受到C++的强（tuo）大（fa）了。</p>
<p>放几张效果图：</p>
<img src="/2022/03/23/Windows/PE%E8%A7%A3%E6%9E%90%E5%99%A8%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/image-20220323043054150.png" alt="image-20220323043054150" style="zoom:33%;">

<img src="/2022/03/23/Windows/PE%E8%A7%A3%E6%9E%90%E5%99%A8%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/image-20220323042942385.png" alt="image-20220323042942385" style="zoom: 33%;">

<p>确实丑哈（</p>
<blockquote>
<p>很久很久没更了，理由包括但不限于假期emo,c++的制裁和懒（，之后还是该做到每周更新的</p>
</blockquote>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>信息的表示和处理</title>
    <url>/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h1><p>​        计算机将8个位的块作为最小的内存寻址单位，也就是字节。而机器级程序将内存视作一个很大的字节数组，称之为<strong>虚拟内存</strong>。</p>
<p>​        在虚拟内存中，每个字节作为单位，由唯一的数字进行标识，这个数字也就叫做它的地址。所有可能的地址集合就叫做虚拟地址空间。</p>
<p>​        虚拟地址空间是一种展现给机器级程序的重要抽象概念，具体由多种硬件和操作系统协同完成。</p>
<p>​        编译器和运行时系统如何将储存器空间进行划分，来对不同程序对象（程序数据，指令，控制信息）进行分配和管理是信息存储的重点。</p>
<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><h3 id="字和字长"><a href="#字和字长" class="headerlink" title="字和字长"></a>字和字长</h3><p>​        字长是指明指针数据类型大小的标准。虚拟地址依赖一个字来编码，所以字长决定的最重要的系统参数就是虚拟地址空间的<strong>最大大小</strong>。一个字长为w的机器，其最多访问2^w^个字节。32位机器的虚拟地址是4GB而64位更是达到了16EB。</p>
<p>​        32位和64位程序的区别并不在于运行的机器，而是编译的方式。绝大多数的64位机器会对32位程序进行向后兼容，同时<code>linux&gt;gcc -m32 prog.c</code>可以在64位电脑上编译出32位的程序，将 -m32 改为 -m64可以编译64位的程序。</p>
<p>​        在过去32位程序和32位机器是主流的组合，而随着64位机器的普及，很多程序对字长的依赖性就暴露了出来，例如C语言中指定一个int类型来存放指针在32位系统上正常而在64位系统上就会导致问题。同时long和unsigned long的典型大小在两类机器上也有所不同。</p>
<h3 id="对象的地址和字节序"><a href="#对象的地址和字节序" class="headerlink" title="对象的地址和字节序"></a>对象的地址和字节序</h3><p>​        在几乎所有的机器上，跨越多字的对象都是连续排列。如果我们要实现跨越多字节的程序对象的寻址，需要知道两个必要条件，对象的地址和内存排列格式。</p>
<p>​        对象的地址指的是它使用字节中的最小的地址，如果有一个int类型x，其四个字节排列在0x100,0x101,0x102,0x103上，那么0x100就是这个对象的地址。</p>
<p>​        在了解字节序之前，我们先将所研究的程序对象的字节进行下划分。以之前的x为例，它一共有32位，我们将第31位称为最高有效位，那么第0位就成为了最低有效位。如果一个字节包含最低有效位在内的8个字节，那么称它为最低有效字节，如果包含了最高有效位在内的8个字节，那么就称为最高有效字节。机器将程序对象按最低有效字节到最高有效字节的顺序存放称为小端序，它的最低有效字节在最前端。反之将最高有效字节放在前面称为大端序。</p>
<p>​        我们设x为0x12345678.最高有效字节应该存储0x78，最低有效字节存储0x12.如果机器在地址0x100中存放了12，在0x103中存放了78，那么这种机器就采用的是小端序。</p>
<p>​        大多数的Inter兼容机都只采用小端序，移动端常用的ARM微处理器可以按两种端序操作，但安卓和iOS操作系统只支持小端序。</p>
<p>​        一般来说，我们看不到字节序带来的影响。然而一方面，在网络传输时，大小端序的机器互通会存在影响，此时我们应该将程序在内部转换为网络标准。另一方面，在直接检查机器级代码的时候，如果不明白字节序会对我们的理解带来障碍。</p>
<h2 id="字符串，代码的表示"><a href="#字符串，代码的表示" class="headerlink" title="字符串，代码的表示"></a>字符串，代码的表示</h2><p>​        字符串和代码的编码差别很大。C语言中的字符串被编码为一个以null结尾的字符数组，每个字符以标准编码表示，最常见的是ASCII，这使得它在任何系统上都得出相同的结果，与字节序和字节大小无关。</p>
<p>​        当指令编码为二进制代码时，不同的机器类型和操作系统会采用不同且不兼容的指令和编码方式，二进制代码很少能在不同机器和操作系统间移植。</p>
<h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><p>​        整数可分为两种类型，只表示非负数的无符号整数和表示正数，负数，0的有符号整数。</p>
<h3 id="编码形式"><a href="#编码形式" class="headerlink" title="编码形式"></a>编码形式</h3><p>​        对于0到2^w^-1的无符号整数和-2^w-1^ 到2^w-1^的有符号整数，我们可以用唯一的w位的位向量来表示。同时对于一个向量x=[x<del>w-1</del>,x<del>w-2</del>,……x<del>0</del>],在特定的规则下，就可以将它与整数映射。</p>
<p>​        对于无符号整数</p>
<p><img src="/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/image-20211209192538409.png" alt="image-20211209192538409"></p>
<p>​        有如下表示</p>
<img src="/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/image-20211209193152681.png" alt="image-20211209193152681" style="zoom:33%;">

<p>​        对于有符号整数</p>
<p><img src="/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/image-20211209192615658.png" alt="image-20211209192615658"></p>
<p>​        有符号整数的最高位x<del>w-1</del>被定义为符号位，有着-2^w-1^的权重，也就是无符号整数中最高位权重的负数。这样一来，我们就可以表达负数。这种给最高位负权的形式叫做补码。</p>
<img src="/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/image-20211209193304347.png" alt="image-20211209193304347" style="zoom:33%;">

<p>​        由于特殊的位模式，补码的范围是不对称的，补码能表示的正数的最大值要比负数的最大值小1。同时，相同位下无符号整数所能表达的范围比最大的有符号整数要大一点。</p>
<blockquote>
<p>有符号整数的其他编码 –反码和原码</p>
<p>反码：最高有效位的权重是-（2^w-1^-1）,比补码要小</p>
<img src="/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/image-20211209200041387.png" alt="image-20211209200041387" style="zoom:50%;">

<p>原码：把最高有效位作为符号位，来决定整个数字的符号</p>
<img src="/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/image-20211209200119482.png" alt="image-20211209200119482" style="zoom:50%;">

<p>两种编码有个奇怪的问题，对于0有正0和负0两种表示：</p>
<p>​        在w = 4时，[0000]都表示为+0，而在反码中[1111]表示-0，在原码中[1000]表示-0，几乎所有的现代机器都采用了补码。</p>
</blockquote>
<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>​        C语言可以实现无符号整数和有符号整数之间的转换。对于一个int类型的数a<code>(unsigned int)a</code>就可以强制类型转换为无符号类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> a = <span class="number">-12345</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> ua = (<span class="keyword">unsigned</span> <span class="keyword">short</span>) a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d, ua = %u\n&quot;</span>,a,ua);</span><br></pre></td></tr></table></figure>

<p><code>a = -12345， ua = 53191</code></p>
<p>​        这样的结果是由于大多数都C语言在实现类型转换的时候不会去改变整数的位级表示，而是改变了同一位表示下的映射关系。</p>
<p>​        同时，请注意 12345+53191=65536（2^16^）,这可以推广到位表示一定的前提下任两个补码和无符号数的关系。</p>
<p>​        C语言同时支持无符号和有符号整数（C以外很少有语言支持无符号整数），同时规定了如果一个运算其中一个运算书是有符号而另一个是无符号的，那么会对有符号数进行隐式的强制转换，对于&lt;  和  &gt;会导致非直观的结果</p>
<img src="/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/image-20211209215013016.png" alt="image-20211209215013016" style="zoom:50%;">

<h3 id="扩展和截断"><a href="#扩展和截断" class="headerlink" title="扩展和截断"></a>扩展和截断</h3><p>​        扩展是从一个较小的数据类型转换到较大类型而保持其大小不变的操作。</p>
<p>​        对于无符号数，我们只需要在表示的开头添加0，这种运算被称为零扩展。对于有符号数，我们则需要对它的符号位进行扩展，即在表示的开头补充上和符号位相同的值。</p>
<p>​        截断是一种和扩展相反的操作。它用来将较大的数据类型转换为较小的类型。</p>
<p>​        对于无符号数，我们可以直接丢弃表示头部的部分位进行截断，而对于有符号数在截断后需要对符号位重新赋予负权。</p>
<h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>​        在进行加法和乘法运算时，常常会出现溢出的情况。两个位表示有4位的数字相加的结果可能需要一个5位的数字表示。我们用截断来应对这种情况，避免数据扩张。</p>
<table>
<thead>
<tr>
<th>截断的结果</th>
</tr>
</thead>
<tbody><tr>
<td>无符号数加法：发生溢出则减去2^w^</td>
</tr>
<tr>
<td>补码加法：正溢出减去2^w^，负溢出加上2^w^</td>
</tr>
<tr>
<td>无符号数乘法：溢出后结果对2^w^取模</td>
</tr>
<tr>
<td>补码乘法：溢出后结果对2^w^取模，再转换成补码</td>
</tr>
</tbody></table>
<p>​        在不同的运算发生溢出时有不同的表述，但是在位级上看，它们都发生了截断运算来保证自己的数据大小不会扩张。整数运算实际上是一种模运算形式。</p>
<h3 id="乘法优化实现"><a href="#乘法优化实现" class="headerlink" title="乘法优化实现"></a>乘法优化实现</h3><p>​        相较于加减法和位运算，乘法显得相当慢。</p>
<p>​        因此，在少量移位，加法和减法足够时，编译器采用如下优化</p>
<p><code>x*14 -&gt; (x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)</code></p>
<p>或者</p>
<p><code>x*14 -&gt; (x&lt;&lt;4)-(x&lt;&lt;1)</code></p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h3><h4 id="定点表示"><a href="#定点表示" class="headerlink" title="定点表示"></a>定点表示</h4><p>​        拿十进制的小数表示法来说，小数点之前的数字按位赋予10的正幂，得到整数值。对于小数点右边的梳子赋予10的负幂，得到小数值。</p>
<p>​        定点表示二进制小数的思路和十进制相似：小数点左边赋予2的正幂，右边赋予2的负幂。来表示小数，如下  <img src="/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/image-20211210103414206.png" alt="image-20211210103414206" style="zoom: 50%;"></p>
<p>​        对于101.11我们会得到5+3/4。</p>
<p>​        事实上用二进制来表示小数很难做到精确，它只能准确的表达能够写成x X 2^y^的数，其他只能通过增加二进制表示的长度来提升精度。</p>
<h4 id="IEEE表示"><a href="#IEEE表示" class="headerlink" title="IEEE表示"></a>IEEE表示</h4><p>​        IEEE表示法更直接地表示能写成x X 2^y^格式的数，并规定以下格式</p>
<p><img src="/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/image-20211210104020169.png" alt="image-20211210104020169"></p>
<table>
<thead>
<tr>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>符号（s）决定数字的正(0)负(1)，0的符号位特殊处理</td>
</tr>
<tr>
<td>尾数（M）一个二进制小数</td>
</tr>
<tr>
<td>阶码（E）对浮点数加权</td>
</tr>
</tbody></table>
<p>​        在这种规定下，我们只需要分别用二进制表示出s,M,E就可以确定下来一个浮点数。IEEE将位表示划分为三个字段分别对这些值编码。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>32位下长度（float）</th>
<th>64位下长度（double）</th>
</tr>
</thead>
<tbody><tr>
<td>符号位：用一个单独的位编码符号s</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>阶码字段：k位解码字段exp = e<del>k-1</del>…e<del>1</del>e<del>0</del>编码阶码E</td>
<td>8</td>
<td>11</td>
</tr>
<tr>
<td>小数字段：n位编码frac = f<del>n-1</del>…f<del>1</del>f<del>0</del>编码尾数M</td>
<td>23</td>
<td>52</td>
</tr>
</tbody></table>
<p>​        根据exp的值，被编码的值可以分成三种情况，规格化，非规格化和特殊值</p>
<p><img src="/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/image-20211210105308430.png" alt="image-20211210105308430"></p>
<table>
<thead>
<tr>
<th></th>
<th>规格化</th>
<th>非规格化</th>
<th>特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>exp不全为0或1</td>
<td>exp全为0</td>
<td>exp全为1</td>
</tr>
<tr>
<td>大小（s&gt;1）</td>
<td>表示大于等于1的数（M = 1+f）</td>
<td>表示近似1到非常接近0的数（M = f）</td>
<td>+∞(小数字段为0)，NaN</td>
</tr>
<tr>
<td>E</td>
<td>e-Bias</td>
<td>1-Bias</td>
<td></td>
</tr>
</tbody></table>
<p>Bias是大小为2^k-1^-1的偏置值。</p>
<h3 id="整数转换为浮点数"><a href="#整数转换为浮点数" class="headerlink" title="整数转换为浮点数"></a>整数转换为浮点数</h3><p>​        接下来我们将整数12345转换为浮点数12345.0</p>
<ol>
<li><p>写出12345的位表示[11000000111001],共14位。</p>
</li>
<li><p>将二进制小数点左移13位创建规格化表示：</p>
<p>12345 = 1.1000000111001 x 2^13^</p>
</li>
<li><p>按照规格化隐含表示1的规定，丢弃开头的1，尾部填充10个0构造小数字段</p>
</li>
<li><p>13+127（Bias）来构造阶码字段，填充在头部</p>
</li>
<li><p>最高位填充0作为表示正数的符号位</p>
<p>这样就构造出来[01000110010000001110010000000000]，也就是IEEE表示的12345.0</p>
</li>
</ol>
<h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>​        浮点运算只能近似的表示实数运算，我们通过舍入来找到最接近的匹配值，而另一种方法是维持实际数字的上界和下界。因此，舍入运算最关键的地方在于确定舍入的方向。</p>
<p>​        IEEE规定了四种舍入的方式。</p>
<table>
<thead>
<tr>
<th>舍入方式</th>
<th>描述</th>
<th>舍入1.40</th>
<th>舍入1.50</th>
<th>舍入-1.50</th>
</tr>
</thead>
<tbody><tr>
<td>向偶数舍入</td>
<td>近似于十进制的四舍五入，多余位位表示大于[1000]进一， 小于直接舍去。多余位位表示为[1000]那么此时最低位为0则舍掉多余位，最低位为1则进位1。</td>
<td>1</td>
<td>2</td>
<td>-2</td>
</tr>
<tr>
<td>向0舍入</td>
<td>正数向下，负数向上舍入</td>
<td>1</td>
<td>1</td>
<td>-1</td>
</tr>
<tr>
<td>向上舍入</td>
<td>对正数，多余位全为0则直接截尾，不全为0则向最低有效位进1；负数不管多余位是多少直接截尾即可。</td>
<td>2</td>
<td>2</td>
<td>-1</td>
</tr>
<tr>
<td>向下舍入</td>
<td>对负数，多余位全为0则直接截尾，不全为0则向最低有效位进1；正数不管多余位是多少直接截尾即可。</td>
<td>1</td>
<td>1</td>
<td>-2</td>
</tr>
</tbody></table>
<p>​        默认的舍入方式是向偶数舍入，其它三种舍入方式常用来确定舍入的界限。舍入方式不仅能运用在确定实数，也能运用在确定二进制小数上。</p>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>​        浮点数的运算和整数运算大体相似，但最后的结果会根据所需的精度要求进行向偶数舍入。但最大的区别在于浮点数不具备结合性和交换性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="number">3.14</span>+<span class="number">1E10</span>) - <span class="number">1E10</span> = <span class="number">0.0</span></span><br><span class="line"><span class="number">3.14</span> + (<span class="number">1E10</span><span class="number">-1E10</span>) = <span class="number">3.14</span></span><br><span class="line">(<span class="number">1E10</span>*<span class="number">1E10</span>)*<span class="number">1E-20</span> = +∞</span><br><span class="line"><span class="number">1E20</span>*(<span class="number">1E20</span>*<span class="number">1E-20</span>) = <span class="number">1E20</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSAPP笔记</category>
      </categories>
      <tags>
        <tag>信息存储</tag>
        <tag>浮点数</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>导入表</title>
    <url>/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h1><p>作用:记录了一个exe或者一个dll所用到的其他模块导出的函数；<br> 所记录的信息有:用了哪些模块(用了哪些dll),用了dll的哪些函数</p>
<p>导入表是为实现代码重用而设置的。</p>
<p>在数据目录中一共有四种类型的数据与导入表数据有关。这四种数据依次为：导入表,导入函数地址表,绑定导入表,延迟加载导入表。这篇文章只介绍最基础的导入表结构和导入函数地址表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"></span><br><span class="line">;数据段</span><br><span class="line">.data</span><br><span class="line">szText db &#x27;HelloWorld&#x27;,0</span><br><span class="line">;代码段</span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">invoke MessageBox,NULL,offset szText,NULL,MB_OK</span><br><span class="line">invoke ExitProcess,NULL</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>以这个helloworld程序为例，展示函数导入的过程。</p>
<h2 id="函数导入"><a href="#函数导入" class="headerlink" title="函数导入"></a>函数导入</h2><h3 id="函数导入过程"><a href="#函数导入过程" class="headerlink" title="函数导入过程"></a>函数导入过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke MessageBox,NULL,offset szText,NULL,MB_OK</span><br><span class="line">invoke ExitProcess,NULL</span><br></pre></td></tr></table></figure>

<p>打开OD</p>
<p>OD可以查看装载在内存中的程序字节码</p>
<p><strong><img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/image-20211219232320849.png" alt="image-20211219232320849"></strong></p>
<p>在开头可以找到两个函数调用。</p>
<p><img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/image-20211219232602548.png" alt="image-20211219232602548">第一个调用语句被编译器解释为从地址0x00401000到0x0040100B的反汇编代码。根据地址0x0040100B处的调用关系来看，该语句还包含0x00401018处的跳转指令。</p>
<p>第二个调用语句被编译器解释为从地址0x00401010到0x00401012的反汇编代码。根据地址0x00401012处的调用关系来看，该语句还包含0x0040101E处的跳转指令。</p>
<p>汇编指令<code>invoke</code>被分解成了3个步骤。</p>
<p>步骤1　压栈。即先将要调用的所有参数push到栈中。压栈时按照先推后参数，再推前参数的规则，即第一个推入栈的应该是调用的最后一个参数MB_OK，最后一个推入栈的参数应该是调用中的第一个参数NULL，尽管两者的值看起来都是0。</p>
<p>步骤2　段内调用。即通过指令call调用一个段内地址，即call 00401018。</p>
<p>步骤3　无条件转移。call指令操作数0x00401018处的值是：FF25 08204000，将该字节码反汇编，得到一个无条件跳转指令，跳转到了位置00402008处。</p>
<blockquote>
<p>010editor可以查看在磁盘中的程序字节码</p>
<p><img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/Users/sanyi/AppData/Roaming/Typora/typora-user-images/image-20211222101756210.png" alt="image-20211222101756210"></p>
<p>可以发现两者字节码完全相同。这意味着，该程序在被装载以后加载的基址和IMAGE_OPTIONAL_HEADER32.ImageBase是相等的，不存在重定位问题（如果两者不相等，则指令中涉及全局操作数的部分就会有不同）。</p>
</blockquote>
<h3 id="导入函数地址"><a href="#导入函数地址" class="headerlink" title="导入函数地址"></a>导入函数地址</h3><p>先看内存中的导入表：</p>
<p>在OD选中0040101E，右键“数据窗口中跟随|内存地址”显示内存从00402000开始的数据</p>
<p><img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/Users/sanyi/AppData/Roaming/Typora/typora-user-images/image-20211222104132121.png" alt="image-20211222104132121"></p>
<p>得到导入函数MessageBoxA和ExitProcess的VA ：76844E10和769A3670（注意端序）</p>
<p>接下来对比文件中的导入表：</p>
<img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/Users/sanyi/AppData/Roaming/Typora/typora-user-images/image-20211222113606944.png" alt="image-20211222113606944" style="zoom: 67%;">

<p>可以看到VA为2076和205C，以MessageBoxA为例：VA - RVA可得到5C&lt;0x92(146)在.rdata段中 再加上PointerToRawData可以得到FOA为065Ch。</p>
<p><img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/Users/sanyi/AppData/Roaming/Typora/typora-user-images/image-20211222114414977.png" alt="image-20211222114414977"></p>
<p>查看065Ch</p>
<p><img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/Users/sanyi/AppData/Roaming/Typora/typora-user-images/image-20211219233953420.png" alt="image-20211219233953420"></p>
<p>为01B1h和MessageBoxA.user32.dll字符串。这是一个”Hint/Name”结构。</p>
<p>既然程序中调用了动态链接库的有关函数，那么程序进程地址空间中也一定会有这些函数的指令代码。也就是说，操作系统会在加载时根据导入表的描述将调用的函数指令字节码复制到进程地址空间中。结合上面所说，我们可以得到导入函数的具体过程：</p>
<ol>
<li><p>在将PE文件装载进内存时，Windows加载器会识别到<code>call &lt;jmp.&amp;usr32.MessageBoxA&gt;</code></p>
</li>
<li><p>段内跳转到<code>jmp dword ptr[&lt;&amp;usr32.MessageBoxA&gt;]</code></p>
</li>
<li><p>加载器继续查找对应位置0x00402008得到值0000205ch（此时函数没有被导入）</p>
</li>
<li><p>然后从文件的0x0000205c处获取函数的名字MessageBoxA和函数在动态链接库里的编号（Hint/Name）</p>
</li>
<li><p>根据函数的Hint/Name从内存地址空间中查找到函数的VA为77d507eah</p>
</li>
<li><p>并将找到的函数地址重新覆盖内存的0x00402008这个位置。</p>
</li>
</ol>
<p>当程序真正被装载进内存以后，0x00402008这个位置就已经被替换成为函数的虚拟内存地址。</p>
<img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/Users/sanyi/AppData/Roaming/Typora/typora-user-images/image-20211222120220079.png" alt="image-20211222120220079" style="zoom:50%;">

<p>事实上，操作系统总是会将该函数所处的动态链接库全部复制到进程地址空间，这些动态链接库便是导入函数的指令宿主。如果一个动态链接库在一个进程中被加载过，且在其他进程中也引用了该链接库的函数，操作系统不会再次加载这个动态链接库，而是通过页面调度机制使两个进程同时访问一个动态链接库。也就是说，为了节约内存资源，操作系统只保证有一份代码存在于物理内存中。</p>
<h2 id="导入表-1"><a href="#导入表-1" class="headerlink" title="导入表"></a>导入表</h2><p>导入表是数据目录中注册的数据类型之一，其描述信息位于数据目录的第2个目录项中。IAT也是数据目录中注册的数据类型之一，其描述信息位于数据目录的第13个目录项中。</p>
<p><img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/Users/sanyi/AppData/Roaming/Typora/typora-user-images/image-20211222121246470.png" alt="image-20211222121246470"></p>
<p><img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/Users/sanyi/AppData/Roaming/Typora/typora-user-images/image-20211222121300065.png" alt="image-20211222121300065"></p>
<p>IAT数据所在文件的偏移地址=0x00000600</p>
<p>导入表数据所在文件的偏移地址=0x00000610</p>
<h3 id="导入表描述符"><a href="#导入表描述符" class="headerlink" title="导入表描述符"></a>导入表描述符</h3><p>导入表由一系列的导入表描述符组成，每组为20字节，最后有一个全为0的数组作为结束标志。</p>
<p>导入表的每一组都是一个结构IMAGE_IMPORT_DESCRIPTOR，每个结构由5个双字组成。</p>
<p><img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/Users/sanyi/AppData/Roaming/Typora/typora-user-images/image-20211222182117196.png" alt="image-20211222182117196"></p>
<h4 id="OriginalFirstThunk"><a href="#OriginalFirstThunk" class="headerlink" title=".OriginalFirstThunk"></a>.OriginalFirstThunk</h4><p>一个特殊的双字，不同时候有不同的解释，同时作为通向另外数据结构的通路桥一，这是一个RVA，它指向了一个结构体的数组INT（Import Name Table）。INT的每一项也是结构体，称为IMAGE_THUNK_DATA</p>
<p>双字最高位为0，表示导入符号是一个数值，该数值是一个RVA。</p>
<p>双字最高位为1，表示导入符号是一个名称。</p>
<h4 id="Name1"><a href="#Name1" class="headerlink" title=".Name1"></a>.Name1</h4><p>是一个RVA，它指向该结构所对应的DLL文件的名称，而这个名称是以“\0”结尾的Ansi字符串。</p>
<h4 id="FirstThunk"><a href="#FirstThunk" class="headerlink" title=".FirstThunk"></a>.FirstThunk</h4><p>指向IAT，作为桥二</p>
<h3 id="双桥结构"><a href="#双桥结构" class="headerlink" title="双桥结构"></a>双桥结构</h3><img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/Users/sanyi/AppData/Roaming/Typora/typora-user-images/image-20211222182914669.png" alt="image-20211222182914669" style="zoom:50%;">

<p>桥一和桥二经过不同的数据结构的通路，最终会指向相同的“Hint/Name”结构（未断裂）</p>
<p>下面是MessageBoxA对应的导入表结构</p>
<p><img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/Users/sanyi/AppData/Roaming/Typora/typora-user-images/image-20211222183109301.png" alt="image-20211222183109301"></p>
<p>可以看到桥一的数值是2054h，找到FOA等于654h，从文件的该位置开始取双字，直到取出的双字为“0”结束。这里在user32.dll中仅使用这一个函数</p>
<p><img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/Users/sanyi/AppData/Roaming/Typora/typora-user-images/image-20211222183214889.png" alt="image-20211222183214889"></p>
<p><img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/Users/sanyi/AppData/Roaming/Typora/typora-user-images/image-20211222183714590.png" alt="image-20211222183714590"></p>
<p>再次换算FOA为65Ch，找到IMAGE_IMPORT_BY_NAME的结构</p>
<p><img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/Users/sanyi/AppData/Roaming/Typora/typora-user-images/image-20211222183249149.png" alt="image-20211222183249149"></p>
<p>这个结构就是桥一的最终目的地“Hint/Name”第一个字表示编号，第二个字表示名称</p>
<p>每一个结构IMAGE_IMPORT_DESCRIPTOR（导入表描述符）都对应一个唯一的动态链接库文件，以及引用了该动态链接库的多个函数，每个函数的最终“值-名称”描述均可以沿着桥1或者桥2找到，这种导入表结构被称为双桥结构。</p>
<p>我们也可以用桥二来寻找函数</p>
<p>导入函数地址表（IAT）是一个双字的数组，每个双字代表的是一个导入函数的VA，该地址称为导入函数地址（Import Address，IA）。IAT中定义了不止一个链接库的函数，为了区分这些从不同链接库引入的函数，规定所有引入函数按照链接库分类；相同链接库的函数地址排列在一起，最后以一个双字的0结束。</p>
<img src="/2021/12/22/Windows/%E5%AF%BC%E5%85%A5%E8%A1%A8/Users/sanyi/AppData/Roaming/Typora/typora-user-images/image-20211222184120682.png" alt="image-20211222184120682" style="zoom:33%;">

<p>在内存中，桥1可以让你找到调用的函数名称或函数的索引编号，桥2却可以帮助你找到该函数指令代码在内存空间的地址。</p>
<p>当PE被加载进虚拟地址空间以后，IAT的内容会被操作系统更改为函数的VA。这个修改最终会导致通向“值-名称”描述的桥2发生断裂，这时我们就只能通过桥一来确认导入了那些函数。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>程序的机器级表示（一）</title>
    <url>/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="程序的机器级表示（一）"><a href="#程序的机器级表示（一）" class="headerlink" title="程序的机器级表示（一）"></a>程序的机器级表示（一）</h1><p>计算机使用多重形式的抽象来隐藏实现的细节，对于机器级编程，需要特别关注ISA和虚拟地址。</p>
<ul>
<li>ISA（Instruction Set Architecture）：指令集架构.定义处理器状态，指令的格式，以及每条指令的影响。ISA将程序的行为描述为好像每条指令都是依次执行。复杂的处理器硬件可以采取措施与每条指令的执行完全同步。</li>
<li>虚拟地址：储存器系统的实现是多个硬件储存器和操作系统的组合，虚拟内存将其抽象为一个非常大的字节数组。</li>
</ul>
<h2 id="相关指令的使用"><a href="#相关指令的使用" class="headerlink" title="相关指令的使用"></a>相关指令的使用</h2><p>预先写好两个程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span> <span class="params">(<span class="keyword">long</span>,<span class="keyword">long</span>,<span class="keyword">long</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> d;</span><br><span class="line">    multstore(<span class="number">2</span>,<span class="number">3</span>,&amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2 * 3 --&gt; %ld\n&quot;</span>,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s= a * b;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//multstroe.c</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span>,<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span> <span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y,<span class="keyword">long</span> *dest)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> t = mult2(x,y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个程序分开都是不能独立运行的，我们可以用<code>linux&gt;gcc -og -o prog main.c multstore.c</code>来连接两个程序来构建一个可执行的文件</p>
<img src="/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20211204155734109.png" alt="image-20211204155734109" style="zoom:33%;">

<p><code>objdump -d prog</code>可以反汇编查看ATT的汇编代码同时查看机器码</p>
<p>可以看到链接器填上了callq 指令调用mult2需要使用的地址，同时出现了一些nop指令用来让代码变为16字节，更好的存放下一个代码块</p>
<p><code>linux&gt;gcc -og -s main.c</code>进行反编译实现汇编代码文件main.s</p>
<p><code>linux&gt;gcc  -og -o main.s</code>进行机器代码实现main.o，此文件需要objdump来查看</p>
<h3 id="ATT和intel"><a href="#ATT和intel" class="headerlink" title="ATT和intel"></a>ATT和intel</h3><table>
<thead>
<tr>
<th></th>
<th>ATT</th>
<th>INTEL</th>
</tr>
</thead>
<tbody><tr>
<td>指令大小后缀</td>
<td>有，如callq</td>
<td>无，只有call，push</td>
</tr>
<tr>
<td>寄存器名称</td>
<td>如%rsp</td>
<td>如rsp</td>
</tr>
<tr>
<td>内存位置表示</td>
<td>（%rbx）</td>
<td>QWOR PTR [rbx]</td>
</tr>
<tr>
<td>多个操作数</td>
<td>二者相反</td>
<td>二者相反</td>
</tr>
<tr>
<td>适用范围</td>
<td>GCC OBJDUMP</td>
<td>微软系列</td>
</tr>
</tbody></table>
<blockquote>
<p>在C中插入汇编代码</p>
<p>GCC内联特性，用asm伪代码在C中包含简短的汇编</p>
<p>将完整的函数放进独立的汇编文件，用汇编器和链接器相连</p>
</blockquote>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><img src="/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20211204162835466.png" alt="image-20211204162835466" style="zoom: 67%;">

<p>​        x86系列实现过80位，10字节的long double浮点类型运算，不过移植性和实用性都很差</p>
<p>​        gcc的汇编代码都有一个字符的后缀来表示操作数的大小，movb表示字节，movw传送字，movl传送双字，movq传送四字。l同时也表示8字节的 double却并不冲突，因为浮点数由一组不同的指令和寄存器操作</p>
<h2 id="信息访问"><a href="#信息访问" class="headerlink" title="信息访问"></a>信息访问</h2><p>x86-64一共有16个寄存器，少数指令会使用某些特定的寄存器。此外有一组标准规范控制如何使用寄存器来管理栈，传参，返回，存储局部和临时数据。</p>
<p><img src="/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20211204171351192.png" alt="image-20211204171351192"></p>
<p>对于生成小于8字节的指令，1,2字节会保持剩下的字节不变，生成4字节数字的指令会把高4位清0</p>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>大多数指令有一个或多个操作数，操作数可以分为三种形式立即数，寄存器和内存。书写有特殊的格式</p>
<img src="/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20211204174509586.png" alt="image-20211204174509586" style="zoom:67%;">

<p>比较神奇的写法</p>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>最频繁使用的指令是数据传送指令，将数据从一个位置复制到另一个位置。最简单的数据传送指令是MOV类，它只将数据从源复制到目的位置，不做任何变化，</p>
<h4 id="MOV类"><a href="#MOV类" class="headerlink" title="MOV类"></a>MOV类</h4><p>mov类由四条指令组成：movb，movw，movl，movq，这些指令仅仅是操作数大小上有不同。</p>
<p>mov的源操作数是一个<strong>立即数</strong> ，储存在寄存器或者内存中，目的操作数指定一个位置，要么是寄存器，要么是内存。</p>
<p>x86-64限制，源和目的操作数<strong>不能同时指向内存地址</strong>，两个内存交换需要多次mov。同时<strong>，不同宽度的寄存器之间直接传输是不允许的</strong>，唯一的例外是通用寄存器和段寄存器之间的传输</p>
<p>mov只能表示32位补码作为源操作数，<strong>符号扩展</strong>得64位的值。movabsq能够以任意64位的立即数值作为源操作数，并只能以寄存器作为目的。</p>
<h4 id="MOVZ类"><a href="#MOVZ类" class="headerlink" title="MOVZ类"></a>MOVZ类</h4><p>movz类相当于mov类的变式，movz类有movzbw,movzbl,movzwl,movzbq,movzwq,前一个大小指示符指源的大小，后一个指目的的大小。</p>
<p>该类数据传输指令会将目的中剩余的字节进行零拓展</p>
<h4 id="MOVS类"><a href="#MOVS类" class="headerlink" title="MOVS类"></a>MOVS类</h4><p>movs类和movz类相似，会对目的操作数剩余的位数进行符号拓展。另外movs类有一个cltq，固定将%eax符号拓展到%rax</p>
<blockquote>
<p>练习题的tip</p>
<p>不同宽度的寄存器之间直接传输是不允许的，唯一的例外是通用寄存器和段寄存器之间的传输</p>
<p>%sl不存在。。。</p>
<p>%ebx不能作为地址</p>
<p>%si是16位寄存器</p>
<p>C中的“指针”就是地址，间接引用指针就是将指针放入寄存器，然后再内存引用中使用寄存器</p>
<p>局部变量常常保存在寄存器中，访问速度远快于内存。</p>
<p>int类型转移是需要特别注意，<strong>（movl）</strong>，其他类型要注意是否有符号。例如movzbl也会清零高四位</p>
</blockquote>
<h4 id="入栈和出栈"><a href="#入栈和出栈" class="headerlink" title="入栈和出栈"></a>入栈和出栈</h4><p>pushq和popq</p>
<p>pushq：相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subq $8 , %rsp</span><br><span class="line">movq %rax , (%rsp)</span><br></pre></td></tr></table></figure>

<p>popq：相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq (%rsp) , %rax</span><br><span class="line">addq $8 , %rsp</span><br></pre></td></tr></table></figure>

<h3 id="算术和逻辑运算"><a href="#算术和逻辑运算" class="headerlink" title="算术和逻辑运算"></a>算术和逻辑运算</h3><h4 id="有效地址加载-leaq类"><a href="#有效地址加载-leaq类" class="headerlink" title="有效地址加载 leaq类"></a>有效地址加载 leaq类</h4><p>实际上leaq是movq的变形，看似内存引用，实际上是将有效地址写入目的操作数。</p>
<ul>
<li>类似于C中的&amp;操作符，为后面的内存引用产生指针</li>
<li>简单的算术操作</li>
</ul>
<img src="/2021/12/13/CSAPP%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20211204201413381.png" alt="image-20211204201413381" style="zoom:50%;">

<h4 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h4><ul>
<li>一元操作：decq，incq，negq。notq等类似于 i++</li>
</ul>
<img src="https://img2018.cnblogs.com/blog/1539443/201811/1539443-20181127212130893-665387977.png" alt="img" style="zoom: 67%;">

<ul>
<li>二元操作：其中第二个操作数既是源又是目的，不过，源操作数是第一个，目的操作数是第二个 <code>X-=Y</code></li>
</ul>
<p>因此第二个操作数不能是立即数，如果第二个操作数是内存地址的时候，处理器必须从内存读出值，操作，再写回内存地址</p>
<h4 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h4><p>先给出移位量，再给出要移位的数。移位两可以是立即数，也可以是存放在单字节寄存器**%cl**中的数。</p>
<p>对于x86-64来说，对于w位的操作数，移位数由%cl的m位来决定 ，满足2^m^ = w,[在%cl为FF时，salb移动7位，salw移动15位，sall移动31位]</p>
<p>如图，左移有两个名字，SAL和SHL，二者并无差异，而SAR和SHR，分别为算术右移和逻辑右移。</p>
<h4 id="八字运算"><a href="#八字运算" class="headerlink" title="八字运算"></a>八字运算</h4><table>
<thead>
<tr>
<th>指令</th>
</tr>
</thead>
<tbody><tr>
<td>clto：八字拓展</td>
</tr>
<tr>
<td>mulq：无符号乘法</td>
</tr>
<tr>
<td>imulq：有符号乘法</td>
</tr>
<tr>
<td>divq：无符号除法</td>
</tr>
<tr>
<td>idivq：有符号除法</td>
</tr>
</tbody></table>
<p>imulq有两种形式，处理器可以通过操作数的个数来判断，对于只有一个操作数时，%rax作为另一个操作数</p>
<p>idivq则是以%rdx和%rax作为128位的被除数，操作数作为除数，商存储在%rax，余数存储在%rdx</p>
<p>此外，对于大多数64位的除法来说，被除数也常常是64位，此时%rdx应该是%rax的0拓展或者符号拓展，符号拓展可以用cqto来完成，不需要操作数。</p>
<p>% rdx （高64位）和% rax（低64位）；一起表示128位八字的数据</p>
]]></content>
      <categories>
        <category>CSAPP笔记</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
</search>
